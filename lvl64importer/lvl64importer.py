# written by carter. 20241230
# "you did what you could, you nurtured a seed, that turned into woods"
import base64, zlib, json, bpy

from math import radians
from mathutils import Vector, Euler
from bpy_extras.object_utils import AddObjectHelper, object_data_add

bl_info = {
    "name": "Lvl64Importer",
    "version": (0, 2, 0),
    "author": "carteeeee",
    "location": "3DView",
    "description": "Plugin for importing *.lvl64 files generated by SM64 Rom Manager.",
    "category": "Import-Export",
    "blender": (3, 2, 0),
}

SCALE = 1 / 100 # sm64 to blender scale
BOX_HEIGHT = 1 # this can be anything >0
LEVEL_ROOT_TYPE = "Level Root"
LEVEL_ROOT_NAME = "Level %s - %s"
OBJECT_TYPE = "Object"
WATER_BOX_TYPE = "Water Box"
WATER_TYPE = "Water"
HAZE_TYPE = "Toxic Haze"
AREA_ROOT_TYPE = "Area Root"
AREA_ROOT_NAME = "Area %s"
AREA_COLL_NAME = "Area Collision"
TERRAINS = [
    "Custom",
    "TERRAIN_GRASS",
    "TERRAIN_STONE",
    "TERRAIN_SNOW",
    "TERRAIN_SAND",
    "TERRAIN_SPOOKY",
    "TERRAIN_WATER",
    "TERRAIN_SLIDE",
]

# start and end lines of bhvs in sm64 map
BHV_START = 7580
BHV_END = 8113

def process_file(mappath, filepath):
    print(f"opening lvl64 file at {filepath}")
    with open(filepath, "rb") as f:
        rawdata = f.read()
    leveljson = json.loads(zlib.decompress(rawdata, -15).decode("ascii"))["Content"]["$values"][0]
    
    print(f"opening sm64 map at {mappath}")
    with open(mappath) as f:
        map = f.readlines()[BHV_START:BHV_END]
    
    root = create_level_root(leveljson, filepath.split("/")[-1])
    
    for area in leveljson["Areas"]:
        process_area(area, root, map)

    return {'FINISHED'}

def create_level_root(data, filename):
    obj = bpy.data.objects.new(LEVEL_ROOT_NAME % (data["LevelID"], filename), None)
    obj.sm64_obj_type = LEVEL_ROOT_TYPE
    bpy.context.scene.collection.objects.link(obj)
    
    ### TODO: implement backgrounds (although this might be something trollengine does?)
    
    obj.actSelectorIgnore = not data["ActSelector"]
    
    return obj

def process_area(area, levelroot, map):
    root = create_area_root(area)
    root.parent = levelroot
    
    coll = area["AreaModel"]["Collision"]["Mesh"]
    make_collision(coll, root)
    
    objs = area["Objects"]
    add_objects(objs, root, map)
    
    boxes = area["SpecialBoxes"]
    print(boxes)
    if boxes:
        add_boxes(boxes, root)
    
    ### TODO: implement visual model & textures

def create_area_root(data):
    obj = bpy.data.objects.new(AREA_ROOT_NAME % data["AreaID"], None)
    obj.sm64_obj_type = AREA_ROOT_TYPE
    bpy.context.scene.collection.objects.link(obj)
    
    obj.areaIndex = data["AreaID"]
    obj.terrainEnum = TERRAINS[data["TerrainType"]]
    obj.echoLevel = hex(data["ReverbLevel"])
    
    obj.showStartDialog = data["ShowMessage"]["Enabled"]
    obj.startDialog = f"DIALOG_{data["ShowMessage"]["DialogID"]:>03}"
    
    music = data["BGMusic"]
    if music is 0:
        obj.noMusic = True
    else:
        obj.noMusic = False
        obj.musicSeqEnum = "Custom"
        obj.music_seq = hex(music)
        
    bpy.context.view_layer.objects.active = obj
    for i, warp in enumerate(data["Warps"]):
        rawbuf = base64.b64decode(warp["Buffer"])
        bpy.ops.bone.add_warp_node(option = i)
        node = obj.warpNodes[i]
        node.warpID = hex(rawbuf[2])
        node.destLevelEnum = "Custom"
        node.destLevel = hex(rawbuf[3])
        node.destArea = hex(rawbuf[4])
        node.destNode = hex(rawbuf[5])
        if rawbuf[6] == 0x80:
            node.warpFlagEnum = "WARP_CHECKPOINT"
        else:
            node.warpFlagEnum = "WARP_NO_CHECKPOINT"
    
    return obj

def make_collision(coll, root):
    rawverts = coll["Vertices"]["$values"]
    offset = int(rawverts[0]["$id"])
    
    verts = [Vector((vert["X"] * SCALE, vert["Z"] * -SCALE, vert["Y"] * SCALE)) for vert in rawverts]
    faces = [
        [int(vert["$ref"]) - offset for vert in tri["Vertices"]["$values"]]
    for tri in coll["Triangles"]["$values"]]
    
    mesh = bpy.data.meshes.new(name = AREA_COLL_NAME)
    mesh.from_pydata(verts, [], faces)
    obj = bpy.data.objects.new(AREA_COLL_NAME, mesh)
    bpy.context.scene.collection.objects.link(obj)
    obj.parent = root
    
    obj.data.materials.append(bpy.data.materials['f3dlite_material']) ### TEMPORARY

def add_objects(objects, root, map):
    for object in objects:
        data = base64.b64decode(object["Buffer"])
        #if int(data[3]) == 0:
        #    continue
        obj = bpy.data.objects.new("Object", None)
        obj.sm64_obj_type = OBJECT_TYPE
        obj.sm64_obj_model = str(int(data[3]))
        
        obj.fast64.sm64.game_object.use_individual_params = True
        obj.fast64.sm64.game_object.bparam1 = hex(data[16])
        obj.fast64.sm64.game_object.bparam2 = hex(data[17])
        obj.fast64.sm64.game_object.bparam3 = hex(data[18])
        obj.fast64.sm64.game_object.bparam4 = hex(data[19])
        
        bhvaddr = int.from_bytes(data[20:24])
        hexaddr = f"{bhvaddr:x}"
        line = locatebhv(hexaddr, map)
        bhv = [i for i in map[line].split(" ") if i != ""][1].strip()
        if (line is -1) or (bhv == "bhvBird") or (bhv == "_behaviorSegmentStart"):
            print(hexaddr, root)
            obj.sm64_obj_behaviour = "bhvStaticObject"
        else:
            obj.sm64_obj_behaviour = bhv

        obj.location = Vector((
            int.from_bytes(data[4:6], "big", signed=True) * SCALE,
            int.from_bytes(data[8:10], "big", signed=True) * -SCALE,
            int.from_bytes(data[6:8], "big", signed=True) * SCALE,
        ))
        
        obj.rotation_euler = Euler((
            radians(int.from_bytes(data[10:12], "big", signed=True)),
            radians(-int.from_bytes(data[14:16], "big", signed=True)),
            radians(int.from_bytes(data[12:14], "big", signed=True)),
        ))
        
        bpy.context.scene.collection.objects.link(obj)
        obj.parent = root

def add_boxes(boxes, root):
    for box in boxes:
        print(box)
        obj = bpy.data.objects.new("Box", None)
        obj.empty_display_type = "CUBE"
        obj.sm64_obj_type = WATER_BOX_TYPE
        obj.waterBoxType = WATER_TYPE if box["Type"] == 0 else HAZE_TYPE
        
        x1 = box["X1"] * SCALE
        y1 = box["Z1"] * SCALE
        x2 = box["X2"] * SCALE
        y2 = box["Z2"] * SCALE
        z = box["Y"] * SCALE
        
        obj.location[0] = (x1 + x2) / 2
        obj.location[1] = (y1 + y2) / 2
        obj.location[2] = z - BOX_HEIGHT / 2
        
        obj.scale[0] = x2 - x1
        obj.scale[1] = y2 - y1
        obj.scale[2] = BOX_HEIGHT
        
        bpy.context.scene.collection.objects.link(obj)
        obj.parent = root

def locatebhv(addr, map):
    for i, bhv in enumerate(map):
        if addr in bhv:
            return i
    return -1

from bpy.props import StringProperty, PointerProperty
from bpy.types import Panel, Operator, PropertyGroup 
from bpy.path import abspath

class ImporterProps(PropertyGroup):
    map_path: StringProperty(
        name = "Map Path",
        description = "Path to sm64.us.map",
        subtype = "FILE_PATH")
    
    lvl64_path: StringProperty(
        name = "Level Path",
        description = "Path to the lvl64 file",
        subtype = "FILE_PATH")

class LVL64ImportOp(Operator):
    bl_idname = "lvl64.import"
    bl_label = "Import LVL64"
    
    def execute(self, context):
        props = context.scene.level_import_props
        return process_file(abspath(props.map_path), abspath(props.lvl64_path))

class LVL64ImportPanel(Panel):
    bl_label = "Import"
    bl_idname = "LVL64_Import"
    bl_space_type = "VIEW_3D"  
    bl_region_type = "UI"
    bl_category = "LVL64 Tools"
    bl_context = "objectmode"
    
    def draw(self, context):
        layout = self.layout
        props = context.scene.level_import_props
        
        col = layout.column(align=True)
        col.label(text="sm64.us.map Path:")
        col.prop(props, "map_path", text="")
        
        col = layout.column(align=True)
        col.label(text="Level Path:")
        col.prop(props, "lvl64_path", text="")
        
        layout.operator("lvl64.import")

classes = (
    ImporterProps,
    LVL64ImportOp,
    LVL64ImportPanel,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)

    bpy.types.Scene.level_import_props = PointerProperty(type=ImporterProps)

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)
    del bpy.types.Scene.level_import_props

if __name__ == "__main__":
    register()
