# written by carter. 20241230
# "you did what you could, you nurtured a seed, that turned into woods"
import base64, zlib, json, bpy

from math import radians
from mathutils import Vector, Euler
from bpy_extras.object_utils import AddObjectHelper, object_data_add

bl_info = {
    "name": "Lvl64Importer",
    "version": (0, 2, 0),
    "author": "carteeeee",
    "location": "3DView",
    "description": "Plugin for importing *.lvl64 files generated by SM64 Rom Manager.",
    "category": "Import-Export",
    "blender": (3, 2, 0),
}

SCALE = 0.01
LEVEL_ROOT_TYPE = "Level Root"
LEVEL_ROOT_NAME = "Level %s"
AREA_ROOT_TYPE = "Area Root"
AREA_ROOT_NAME = "Area %s"
AREA_COLL_NAME = "Area Collision"
TERRAINS = [
    "Custom",
    "TERRAIN_GRASS",
    "TERRAIN_STONE",
    "TERRAIN_SNOW",
    "TERRAIN_SAND",
    "TERRAIN_SPOOKY",
    "TERRAIN_WATER",
    "TERRAIN_SLIDE",
]

# start and end lines of bhvs in sm64 map
BHV_START = 7580
BHV_END = 8113

def process_file(mappath, filepath):
    print(f"opening lvl64 file at {filepath}")
    with open(filepath, "rb") as f:
        rawdata = f.read()
    leveljson = json.loads(zlib.decompress(rawdata, -15).decode("ascii"))["Content"]["$values"][0]
    
    print(f"opening sm64 map at {mappath}")
    with open(mappath) as f:
        map = f.readlines()[BHV_START:BHV_END]
    
    root = create_level_root(leveljson)
    
    for area in leveljson["Areas"]:
        process_area(area, root, map)

    return {'FINISHED'}

def create_level_root(data):
    obj = bpy.data.objects.new(LEVEL_ROOT_NAME % data["LevelID"], None)
    obj.sm64_obj_type = LEVEL_ROOT_TYPE
    bpy.context.scene.collection.objects.link(obj)
    
    ### TODO: implement backgrounds (although this might be something trollengine does?)
    
    obj.actSelectorIgnore = not data["ActSelector"]
    
    
    return obj

def process_area(area, levelroot, map):
    root = create_area_root(area)
    root.parent = levelroot
    
    coll = area["AreaModel"]["Collision"]["Mesh"]
    make_collision(coll, root)
    
    objs = area["Objects"]
    add_objects(objs, root, map)
    
    ### TODO: implement visual model & textures

def create_area_root(data):
    obj = bpy.data.objects.new(AREA_ROOT_NAME % data["AreaID"], None)
    obj.sm64_obj_type = AREA_ROOT_TYPE
    bpy.context.scene.collection.objects.link(obj)
    
    obj.areaIndex = data["AreaID"]
    obj.terrainEnum = TERRAINS[data["TerrainType"]]
    obj.echoLevel = hex(data["ReverbLevel"])
    ### TODO: add greeting dialog
    music = data["BGMusic"]
    if music is 0:
        obj.noMusic = True
    else:
        obj.noMusic = False
        obj.musicSeqEnum = "Custom"
        obj.music_seq = hex(music)
        
    bpy.context.view_layer.objects.active = obj
    for i, warp in enumerate(data["Warps"]):
        rawbuf = base64.b64decode(warp["Buffer"])
        bpy.ops.bone.add_warp_node(option = i)
        node = obj.warpNodes[i]
        node.warpID = hex(rawbuf[2])
        node.destLevelEnum = "Custom"
        node.destLevel = hex(rawbuf[3])
        node.destArea = hex(rawbuf[4])
        node.destNode = hex(rawbuf[5])
        if rawbuf[6] == 0x80:
            node.warpFlagEnum = "WARP_CHECKPOINT"
        else:
            node.warpFlagEnum = "WARP_NO_CHECKPOINT"
    
    return obj

def make_collision(coll, root):
    rawverts = coll["Vertices"]["$values"]
    offset = int(rawverts[0]["$id"])
    
    verts = [Vector((vert["X"] * SCALE, vert["Z"] * -SCALE, vert["Y"] * SCALE)) for vert in rawverts]
    faces = [
        [int(vert["$ref"]) - offset for vert in tri["Vertices"]["$values"]]
    for tri in coll["Triangles"]["$values"]]
    
    mesh = bpy.data.meshes.new(name = AREA_COLL_NAME)
    mesh.from_pydata(verts, [], faces)
    obj = bpy.data.objects.new(AREA_COLL_NAME, mesh)
    bpy.context.scene.collection.objects.link(obj)
    obj.parent = root
    
    obj.data.materials.append(bpy.data.materials['f3dlite_material']) ### TEMPORARY

def add_objects(objects, root, map):
    for object in objects:
        data = base64.b64decode(object["Buffer"])
        if int(data[3]) == 0:
            continue
        obj = bpy.data.objects.new("Object", None)
        obj.sm64_obj_type = "Object"
        obj.sm64_obj_model = str(int(data[3]))
        
        obj.fast64.sm64.game_object.use_individual_params = True
        obj.fast64.sm64.game_object.bparam1 = hex(data[16])
        obj.fast64.sm64.game_object.bparam2 = hex(data[17])
        obj.fast64.sm64.game_object.bparam3 = hex(data[18])
        obj.fast64.sm64.game_object.bparam4 = hex(data[19])
        
        bhvaddr = int.from_bytes(data[20:24])
        hexaddr = f"{bhvaddr:x}"
        line = locatebhv(hexaddr, map)
        bhv = [i for i in map[line].split(" ") if i != ""][1].strip()
        if (line is -1) or (bhv == "bhvBird"):
            print(hexaddr, root)
            obj.sm64_obj_behaviour = "bhvStaticObject"
        else:
            obj.sm64_obj_behaviour = bhv

        obj.location = Vector((
            int.from_bytes(data[4:6], "big", signed=True) * SCALE,
            int.from_bytes(data[8:10], "big", signed=True) * -SCALE,
            int.from_bytes(data[6:8], "big", signed=True) * SCALE,
        ))
        
        obj.rotation_euler = Euler((
            radians(int.from_bytes(data[10:12], "big", signed=True)),
            radians(-int.from_bytes(data[14:16], "big", signed=True)),
            radians(int.from_bytes(data[12:14], "big", signed=True)),
        ))
        
        bpy.context.scene.collection.objects.link(obj)
        obj.parent = root

def locatebhv(addr, map):
    for i, bhv in enumerate(map):
        if addr in bhv:
            return i
    return -1

from bpy.props import StringProperty, PointerProperty
from bpy.types import Panel, Operator, PropertyGroup 
from bpy.path import abspath

class ImporterProps(PropertyGroup):
    map_path: StringProperty(
        name = "Map Path",
        description = "Path to sm64.us.map",
        subtype = "FILE_PATH")
    
    lvl64_path: StringProperty(
        name = "Level Path",
        description = "Path to the lvl64 file",
        subtype = "FILE_PATH")

class LVL64ImportOp(Operator):
    bl_idname = "lvl64.import"
    bl_label = "Import LVL64"
    
    def execute(self, context):
        props = context.scene.level_import_props
        return process_file(abspath(props.map_path), abspath(props.lvl64_path))

class LVL64ImportPanel(Panel):
    bl_label = "Import"
    bl_idname = "LVL64_Import"
    bl_space_type = "VIEW_3D"  
    bl_region_type = "UI"
    bl_category = "LVL64 Tools"
    bl_context = "objectmode"
    
    def draw(self, context):
        layout = self.layout
        props = context.scene.level_import_props
        
        col = layout.column(align=True)
        col.label(text="sm64.us.map Path:")
        col.prop(props, "map_path", text="")
        
        col = layout.column(align=True)
        col.label(text="Level Path:")
        col.prop(props, "lvl64_path", text="")
        
        layout.operator("lvl64.import")

classes = (
    ImporterProps,
    LVL64ImportOp,
    LVL64ImportPanel,
)

def register():
    for cls in classes:
        bpy.utils.register_class(cls)

    bpy.types.Scene.level_import_props = PointerProperty(type=ImporterProps)

def unregister():
    for cls in reversed(classes):
        bpy.utils.unregister_class(cls)
    del bpy.types.Scene.level_import_props

if __name__ == "__main__":
    register()
